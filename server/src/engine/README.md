This is baby step 0 of the engine, it handles multiple players, it can make them move and shoot, it handles collisions with the tilemap (still kind of buggy around tile edges) and does hitscan to determine if the bullets hit or miss. It also does basic lag compensation by storing a fair amount of snapshots (a snapshot is dropped if its tick is older than the current one minus MAX_PING).

- **world**:
  this is the central piece. It stores all player and entities, it updates their state as fast as possible (at most CLIENT_RATE time per second), it handles bullet collisions, ...
- **entity**: the base class for all players and ai ennemies
- **player**: an entity with an IP address, nothing more
- **controller**:
  this is what computes the control that will be executed by the entities. For the players, the controls are received by the server and stored in a ring buffer until they are applied, for the other entities, we define an AI object that will produce controls
- **ai**:
  for now, just something so that I can see stuff moving on my screen.
- **weapon**: pretty self explanatory huh ? There is class called Weapons (plural) here that loads all available weapons from an XML file and stores them for easy access
- **tilemap**:
  contains TileMap and TileSet structs. TileMap is the representation used by the engine to process collisions, tileset is stored to be sent to the clients over TCP. It is only used at the very beginning to determine what cells are solid.
  There is also a class called TilemapLoader that loads the tilemap and tileset from XML files generated by Tiled Map Editor
- **collision**: collisions. The code for entity/map collision has been inspired (a lot) by HaxeFlixel collision code.
